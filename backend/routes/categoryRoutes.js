// backend/routes/categoryRoutes.js - COMPLETE UPDATED WITH AUTO-POPULATION
const express = require('express');
const router = express.Router();
const Category = require('../models/category');
const Product = require('../models/product');
const { auth, adminAuth } = require("../middleware/auth");

// GET all categories - WITH AUTO-POPULATION FROM PRODUCTS
router.get('/', async (req, res) => {
  try {
    // First, try to get categories from the categories collection
    let categories = await Category.find().sort({ name: 1 });
    
    // If categories collection is empty, check products and auto-populate
    if (!categories || categories.length === 0) {
      console.log("Categories collection is empty. Checking products for existing categories...");
      
      // Get unique categories from existing products
      const productCategories = await Product.distinct("category");
      
      if (productCategories && productCategories.length > 0) {
        console.log(`Found ${productCategories.length} categories in products. Auto-creating category entries...`);
        
        // Create category entries for each unique product category
        const createdCategories = [];
        
        for (const catName of productCategories) {
          if (catName && catName.trim()) {
            // Check if category already exists (case-insensitive)
            const existingCat = await Category.findOne({ 
              name: { $regex: new RegExp(`^${catName}$`, 'i') } 
            });
            
            if (!existingCat) {
              try {
                // Create new category
                const newCategory = new Category({
                  name: catName.toLowerCase().trim(),
                  description: `${catName.charAt(0).toUpperCase() + catName.slice(1)} products`
                  // ID will be auto-generated by pre-save hook in Category model
                });
                
                await newCategory.save();
                createdCategories.push(newCategory);
              } catch (catError) {
                console.error(`Error creating category "${catName}":`, catError);
                // Continue with other categories
              }
            }
          }
        }
        
        if (createdCategories.length > 0) {
          console.log(`Created ${createdCategories.length} new categories from products.`);
        }
        
        // Fetch categories again
        categories = await Category.find().sort({ name: 1 });
      }
    }
    
    // Format categories for frontend
    const formattedCategories = categories.map(cat => ({
      id: cat.id,
      value: cat.name,
      label: cat.name.charAt(0).toUpperCase() + cat.name.slice(1),
      description: cat.description || '',
      productCount: 0 // We'll add this later if needed
    }));
    
    // Get actual product count for each category
    for (let category of formattedCategories) {
      try {
        const count = await Product.countDocuments({ category: category.value });
        category.productCount = count;
      } catch (countError) {
        console.error(`Error counting products for category ${category.value}:`, countError);
        category.productCount = 0;
      }
    }
    
    const categoryNames = categories.map(cat => cat.name);
    
    res.json({
      success: true,
      categories: categoryNames,
      formattedCategories: formattedCategories,
      count: categories.length,
      message: categories.length === 0 ? 
        "No categories found. Add a category first." : 
        `${categories.length} categories loaded`
    });
    
  } catch (error) {
    console.error('Error fetching categories:', error);
    
    // Try fallback: extract directly from products
    try {
      console.log("Trying fallback: extracting categories from products...");
      const productCategories = await Product.distinct("category");
      const uniqueCategories = productCategories.filter(cat => cat && cat.trim()).sort();
      
      const formattedCategories = uniqueCategories.map((cat, index) => ({
        id: index + 1,
        value: cat.toLowerCase(),
        label: cat.charAt(0).toUpperCase() + cat.slice(1),
        description: `${cat} products`,
        productCount: 0
      }));
      
      res.json({
        success: true,
        categories: uniqueCategories,
        formattedCategories: formattedCategories,
        count: uniqueCategories.length,
        message: "Categories extracted from products"
      });
      
    } catch (fallbackError) {
      console.error('Fallback also failed:', fallbackError);
      
      // Final fallback to basic categories
      res.json({
        success: true,
        categories: ["book", "stationery"],
        formattedCategories: [
          { 
            id: 1, 
            value: "book", 
            label: "Book", 
            description: "Books and reading materials",
            productCount: 0
          },
          { 
            id: 2, 
            value: "stationery", 
            label: "Stationery", 
            description: "Office and school supplies",
            productCount: 0
          }
        ],
        count: 2,
        message: "Using default categories"
      });
    }
  }
});

// POST add new category - SIMPLIFIED WORKING VERSION
router.post('/', adminAuth, async (req, res) => {
  try {
    console.log("=== CATEGORY CREATE REQUEST ===");
    console.log("Body:", req.body);
    
    const { name, description } = req.body;
    
    if (!name || !name.trim()) {
      return res.status(400).json({
        success: false,
        message: 'Category name is required'
      });
    }
    
    const categoryName = name.trim().toLowerCase();
    console.log("Category name:", categoryName);
    
    // SIMPLIFIED: Check if category exists
    const existingCategory = await Category.findOne({ name: categoryName });
    if (existingCategory) {
      return res.status(400).json({
        success: false,
        message: `Category "${categoryName}" already exists`
      });
    }
    
    // SIMPLIFIED: Create category WITHOUT auto-increment hook
    // First, get the next ID manually
    const maxCategory = await Category.findOne().sort({ id: -1 });
    const nextId = maxCategory ? maxCategory.id + 1 : 1;
    
    // Create category with manual ID
    const category = new Category({
      id: nextId, // Manually set ID
      name: categoryName,
      description: description || `${categoryName.charAt(0).toUpperCase() + categoryName.slice(1)} products`
    });
    
    await category.save();
    
    // Update counter for consistency
    try {
      const Counter = require('../models/counter');
      await Counter.findByIdAndUpdate(
        { _id: "categoryId" },
        { $set: { sequence_value: nextId + 1 } },
        { upsert: true }
      );
    } catch (counterError) {
      console.log("Counter update failed, but category saved:", counterError.message);
    }
    
    console.log("✅ Category created:", category);
    
    res.status(201).json({
      success: true,
      message: 'Category added successfully',
      category: {
        id: category.id,
        name: category.name,
        description: category.description
      }
    });
    
  } catch (error) {
    console.error("❌ CATEGORY CREATE ERROR:", error.message);
    
    // Handle specific errors
    if (error.code === 11000) {
      return res.status(400).json({
        success: false,
        message: 'Category name already exists'
      });
    }
    
    res.status(500).json({
      success: false,
      message: 'Failed to create category',
      error: error.message
    });
  }
});

// PUT update category (Admin only)
router.put('/:id', adminAuth, async (req, res) => {
  try {
    const { name, description } = req.body;
    const categoryId = req.params.id;
    
    if (!name || !name.trim()) {
      return res.status(400).json({
        success: false,
        message: 'Category name is required'
      });
    }
    
    const categoryName = name.trim().toLowerCase();
    
    // Basic validation
    if (categoryName.length > 50) {
      return res.status(400).json({
        success: false,
        message: 'Category name is too long (max 50 characters)'
      });
    }
    
    // Check if category exists
    const category = await Category.findOne({ id: Number(categoryId) });
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }
    
    // Check if new name already exists (excluding current category, case-insensitive)
    const existingCategory = await Category.findOne({ 
      name: { $regex: new RegExp(`^${categoryName}$`, 'i') },
      id: { $ne: Number(categoryId) }
    });
    
    if (existingCategory) {
      return res.status(400).json({
        success: false,
        message: 'Category name already exists'
      });
    }
    
    // Update category name if changed
    if (category.name !== categoryName) {
      // Update all products with old category name to new category name
      await Product.updateMany(
        { category: category.name },
        { $set: { category: categoryName } }
      );
      category.name = categoryName;
    }
    
    // Update description if provided
    if (description !== undefined) {
      category.description = description;
    }
    
    category.updated_at = new Date();
    await category.save();
    
    res.json({
      success: true,
      message: 'Category updated successfully',
      category: {
        id: category.id,
        name: category.name,
        description: category.description,
        updated_at: category.updated_at
      }
    });
  } catch (error) {
    console.error('Error updating category:', error);
    res.status(500).json({
      success: false,
      message: 'Error updating category',
      error: error.message
    });
  }
});

// DELETE category (Admin only)
router.delete('/:id', adminAuth, async (req, res) => {
  try {
    const categoryId = req.params.id;
    
    // Check if category exists
    const category = await Category.findOne({ id: Number(categoryId) });
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }
    
    // Check if category is being used by any products
    const productCount = await Product.countDocuments({ category: category.name });
    if (productCount > 0) {
      return res.status(400).json({
        success: false,
        message: 'Cannot delete category. There are products using this category.',
        productCount: productCount,
        suggestion: 'Please reassign or delete the products first, or update the category instead.'
      });
    }
    
    // Delete category
    await Category.findOneAndDelete({ id: Number(categoryId) });
    
    res.json({
      success: true,
      message: 'Category deleted successfully',
      deletedCategory: {
        id: category.id,
        name: category.name
      }
    });
  } catch (error) {
    console.error('Error deleting category:', error);
    res.status(500).json({
      success: false,
      message: 'Error deleting category',
      error: error.message
    });
  }
});

// GET category by ID
router.get('/:id', async (req, res) => {
  try {
    const categoryId = req.params.id;
    
    const category = await Category.findOne({ id: Number(categoryId) });
    if (!category) {
      return res.status(404).json({
        success: false,
        message: 'Category not found'
      });
    }
    
    // Get product count for this category
    const productCount = await Product.countDocuments({ category: category.name });
    
    // Get some sample products from this category
    const sampleProducts = await Product.find({ category: category.name })
      .limit(5)
      .select('id name price stock_quantity');
    
    res.json({
      success: true,
      category: {
        ...category.toObject(),
        productCount: productCount,
        sampleProducts: sampleProducts
      }
    });
  } catch (error) {
    console.error('Error fetching category:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching category',
      error: error.message
    });
  }
});

// GET categories with product counts (for dashboard)
router.get('/stats/summary', async (req, res) => {
  try {
    const categories = await Category.find().sort({ name: 1 });
    
    const categoriesWithStats = await Promise.all(
      categories.map(async (cat) => {
        const productCount = await Product.countDocuments({ category: cat.name });
        const inStockCount = await Product.countDocuments({ 
          category: cat.name, 
          stock_quantity: { $gt: 0 } 
        });
        
        return {
          id: cat.id,
          name: cat.name,
          label: cat.name.charAt(0).toUpperCase() + cat.name.slice(1),
          description: cat.description,
          productCount: productCount,
          inStockCount: inStockCount,
          outOfStockCount: productCount - inStockCount
        };
      })
    );
    
    res.json({
      success: true,
      categories: categoriesWithStats,
      totalCategories: categories.length,
      totalProducts: await Product.countDocuments()
    });
  } catch (error) {
    console.error('Error fetching category stats:', error);
    res.status(500).json({
      success: false,
      message: 'Error fetching category statistics',
      error: error.message
    });
  }
});

module.exports = router;